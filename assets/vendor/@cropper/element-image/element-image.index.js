/**
 * Bundled by jsDelivr using Rollup v2.79.2 and Terser v5.39.0.
 * Original file: /npm/@cropper/element-image@2.0.0/dist/element-image.esm.raw.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import t from"@cropper/element";import{CROPPER_IMAGE as i,CROPPER_CANVAS as s,on as a,EVENT_ACTION_START as e,EVENT_ACTION_END as n,EVENT_ACTION as r,EVENT_LOAD as o,off as h,ACTION_TRANSFORM as l,ACTION_ROTATE as c,ACTION_SCALE as $,ACTION_NONE as d,CROPPER_SELECTION as m,ACTION_MOVE as g,once as u,EVENT_ERROR as b,isFunction as f,isNumber as v,toAngleInRadian as C,multiplyMatrices as p,EVENT_TRANSFORM as A}from"@cropper/utils";const x=new WeakMap,k=["alt","crossorigin","decoding","importance","loading","referrerpolicy","sizes","src","srcset"];class w extends t{constructor(){super(...arguments),this.$matrix=[1,0,0,1,0,0],this.$onLoad=null,this.$onCanvasAction=null,this.$onCanvasActionEnd=null,this.$onCanvasActionStart=null,this.$actionStartTarget=null,this.$style=":host{display:inline-block}img{display:block;height:100%;max-height:none!important;max-width:none!important;min-height:0!important;min-width:0!important;width:100%}",this.$image=new Image,this.initialCenterSize="contain",this.rotatable=!1,this.scalable=!1,this.skewable=!1,this.slottable=!1,this.translatable=!1}set $canvas(t){x.set(this,t)}get $canvas(){return x.get(this)}static get observedAttributes(){return super.observedAttributes.concat(k,["initial-center-size","rotatable","scalable","skewable","translatable"])}attributeChangedCallback(t,i,s){Object.is(s,i)||(super.attributeChangedCallback(t,i,s),k.includes(t)&&this.$image.setAttribute(t,s))}$propertyChangedCallback(t,i,s){if(!Object.is(s,i)&&(super.$propertyChangedCallback(t,i,s),"initialCenterSize"===t))this.$nextTick((()=>{this.$center(s)}))}connectedCallback(){super.connectedCallback();const{$image:t}=this,i=this.closest(this.$getTagNameOf(s));i&&(this.$canvas=i,this.$setStyles({display:"block",position:"absolute"}),this.$onCanvasActionStart=t=>{var i,s;this.$actionStartTarget=null===(s=null===(i=t.detail)||void 0===i?void 0:i.relatedEvent)||void 0===s?void 0:s.target},this.$onCanvasActionEnd=()=>{this.$actionStartTarget=null},this.$onCanvasAction=this.$handleAction.bind(this),a(i,e,this.$onCanvasActionStart),a(i,n,this.$onCanvasActionEnd),a(i,r,this.$onCanvasAction)),this.$onLoad=this.$handleLoad.bind(this),a(t,o,this.$onLoad),this.$getShadowRoot().appendChild(t)}disconnectedCallback(){const{$image:t,$canvas:i}=this;i&&(this.$onCanvasActionStart&&(h(i,e,this.$onCanvasActionStart),this.$onCanvasActionStart=null),this.$onCanvasActionEnd&&(h(i,n,this.$onCanvasActionEnd),this.$onCanvasActionEnd=null),this.$onCanvasAction&&(h(i,r,this.$onCanvasAction),this.$onCanvasAction=null)),t&&this.$onLoad&&(h(t,o,this.$onLoad),this.$onLoad=null),this.$getShadowRoot().removeChild(t),super.disconnectedCallback()}$handleLoad(){const{$image:t}=this;this.$setStyles({width:t.naturalWidth,height:t.naturalHeight}),this.$canvas&&this.$center(this.initialCenterSize)}$handleAction(t){if(this.hidden||!(this.rotatable||this.scalable||this.translatable))return;const{$canvas:i}=this,{detail:s}=t;if(s){const{relatedEvent:t}=s;let{action:a}=s;switch(a!==l||this.rotatable&&this.scalable||(a=this.rotatable?c:this.scalable?$:d),a){case g:if(this.translatable){let a=null;t&&(a=t.target.closest(this.$getTagNameOf(m))),a||(a=i.querySelector(this.$getTagNameOf(m))),a&&a.multiple&&!a.active&&(a=i.querySelector(`${this.$getTagNameOf(m)}[active]`)),a&&!a.hidden&&a.movable&&!a.dynamic&&this.$actionStartTarget&&a.contains(this.$actionStartTarget)||this.$move(s.endX-s.startX,s.endY-s.startY)}break;case c:if(this.rotatable)if(t){const{x:i,y:a}=this.getBoundingClientRect();this.$rotate(s.rotate,t.clientX-i,t.clientY-a)}else this.$rotate(s.rotate);break;case $:if(this.scalable)if(t){const i=t.target.closest(this.$getTagNameOf(m));if(!i||!i.zoomable||i.zoomable&&i.dynamic){const{x:i,y:a}=this.getBoundingClientRect();this.$zoom(s.scale,t.clientX-i,t.clientY-a)}}else this.$zoom(s.scale);break;case l:if(this.rotatable&&this.scalable){const{rotate:i}=s;let{scale:a}=s;a<0?a=1/(1-a):a+=1;const e=Math.cos(i),n=Math.sin(i),[r,o,h,l]=[e*a,n*a,-n*a,e*a];if(t){const i=this.getBoundingClientRect(),s=t.clientX-i.x,a=t.clientY-i.y,[e,n,c,$]=this.$matrix,d=s-i.width/2,m=a-i.height/2,g=(d*$-c*m)/(e*$-c*n),u=(m*e-n*d)/(e*$-c*n);this.$transform(r,o,h,l,g*(1-r)+u*h,u*(1-l)+g*o)}else this.$transform(r,o,h,l,0,0)}}}}$ready(t){const{$image:i}=this,s=new Promise(((t,s)=>{const a=new Error("Failed to load the image source");if(i.complete)i.naturalWidth>0&&i.naturalHeight>0?t(i):s(a);else{const e=()=>{h(i,b,n),t(i)},n=()=>{h(i,o,e),s(a)};u(i,o,e),u(i,b,n)}}));return f(t)&&s.then((i=>(t(i),i))),s}$center(t){const{parentElement:i}=this;if(!i)return this;const s=i.getBoundingClientRect(),a=s.width,e=s.height,{x:n,y:r,width:o,height:h}=this.getBoundingClientRect(),l=n+o/2,c=r+h/2,$=s.x+a/2,d=s.y+e/2;if(this.$move($-l,d-c),t&&(o!==a||h!==e)){const i=a/o,s=e/h;switch(t){case"cover":this.$scale(Math.max(i,s));break;case"contain":this.$scale(Math.min(i,s))}}return this}$move(t,i=t){if(this.translatable&&v(t)&&v(i)){const[s,a,e,n]=this.$matrix,r=(t*n-e*i)/(s*n-e*a),o=(i*s-a*t)/(s*n-e*a);this.$translate(r,o)}return this}$moveTo(t,i=t){if(this.translatable&&v(t)&&v(i)){const[s,a,e,n]=this.$matrix,r=(t*n-e*i)/(s*n-e*a),o=(i*s-a*t)/(s*n-e*a);this.$setTransform(s,a,e,n,r,o)}return this}$rotate(t,i,s){if(this.rotatable){const a=C(t),e=Math.cos(a),n=Math.sin(a),[r,o,h,l]=[e,n,-n,e];if(v(i)&&v(s)){const[t,a,e,n]=this.$matrix,{width:c,height:$}=this.getBoundingClientRect(),d=i-c/2,m=s-$/2,g=(d*n-e*m)/(t*n-e*a),u=(m*t-a*d)/(t*n-e*a);this.$transform(r,o,h,l,g*(1-r)-u*h,u*(1-l)-g*o)}else this.$transform(r,o,h,l,0,0)}return this}$zoom(t,i,s){if(!this.scalable||0===t)return this;if(t<0?t=1/(1-t):t+=1,v(i)&&v(s)){const[a,e,n,r]=this.$matrix,{width:o,height:h}=this.getBoundingClientRect(),l=i-o/2,c=s-h/2,$=(l*r-n*c)/(a*r-n*e),d=(c*a-e*l)/(a*r-n*e);this.$transform(t,0,0,t,$*(1-t),d*(1-t))}else this.$scale(t);return this}$scale(t,i=t){return this.scalable&&this.$transform(t,0,0,i,0,0),this}$skew(t,i=0){if(this.skewable){const s=C(t),a=C(i);this.$transform(1,Math.tan(a),Math.tan(s),1,0,0)}return this}$translate(t,i=t){return this.translatable&&v(t)&&v(i)&&this.$transform(1,0,0,1,t,i),this}$transform(t,i,s,a,e,n){return v(t)&&v(i)&&v(s)&&v(a)&&v(e)&&v(n)?this.$setTransform(p(this.$matrix,[t,i,s,a,e,n])):this}$setTransform(t,i,s,a,e,n){if((this.rotatable||this.scalable||this.skewable||this.translatable)&&(Array.isArray(t)&&([t,i,s,a,e,n]=t),v(t)&&v(i)&&v(s)&&v(a)&&v(e)&&v(n))){const r=[...this.$matrix],o=[t,i,s,a,e,n];if(!1===this.$emit(A,{matrix:o,oldMatrix:r}))return this;this.$matrix=o,this.style.transform=`matrix(${o.join(", ")})`}return this}$getTransform(){return this.$matrix.slice()}$resetTransform(){return this.$setTransform([1,0,0,1,0,0])}}w.$name=i,w.$version="2.0.0";export{w as default};
